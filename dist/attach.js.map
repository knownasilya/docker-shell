{"version":3,"sources":["../lib/attach.js"],"names":["attach","debug","container","started","logs","stream","stdin","stdout","stderr","then","streamc","reject","Error","start","wait","res","stop","catch","err","spawn","bind","kill","remove","force","v","command","proc","write","JSON","stringify","type","Transform","transform","chunk","_","next","toString","push","demux","pipe","split","parse","mapSync","data","event","emit","code","unpipe"],"mappings":"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","file":"attach.js","sourcesContent":["import Bluebird from 'bluebird';\nimport { EventEmitter } from 'events';\nimport setupDebug from 'debug';\nimport es from 'event-stream';\nimport stream from 'stream';\nimport demuxer from './demuxer';\n\nconst debug = setupDebug('docker-shell:attach');\n\nexport default function attach(container, started) {\n  return container.attach({\n    logs: true,\n    stream: true,\n    stdin: true,\n    stdout: true,\n    stderr: true\n  }).then((streamc) => {\n    if (!streamc) return Bluebird.reject(new Error('Failed to attach container stream'));\n\n    if (!started) {\n      debug('starting container');\n      // start, and wait for it to be done\n      return container.start().then(() => {\n        debug('started container');\n\n        container.wait()\n          .then((res) => {\n            debug('done with container, success', res);\n            container.stop();\n          })\n          .catch((err) => {\n            debug('done with container, erred', err);\n            container.stop();\n          });\n\n      }).then(() => {\n        return {\n          spawn: spawn.bind(null, streamc),\n          kill,\n          container\n        };\n      });\n    }\n\n    return {\n      spawn: spawn.bind(null, streamc),\n      kill,\n      container\n    };\n  })\n\n  function kill() {\n    return container.remove({\n      force: true, // Stop container and remove\n      v: true // Remove any attached volumes\n    });\n  }\n\n  function spawn(streamc, command) {\n    debugger;\n    const proc = new EventEmitter();\n\n    proc.kill = function () {\n      streamc.write(`${JSON.stringify({type: 'kill'})}\\n`);\n    };\n    proc.stdout = new stream.Transform({\n      transform(chunk, _, next) {\n        debug('proc.stdout', chunk.toString());\n        this.push(chunk);\n        next();\n      }\n    });\n    proc.stderr = new stream.Transform({\n      transform(chunk, _, next) {\n        debug('proc.stderr', chunk.toString());\n        this.push(chunk);\n        next();\n      }\n    });\n    proc.stdin = streamc;\n\n    var stdout = new stream.Transform({\n      transform(chunk, _, next) {\n        debug('stdout', chunk.toString());\n        this.push(chunk);\n        next();\n      }\n    });\n    var stderr = new stream.Transform({\n      transform(chunk, _, next) {\n        debug('stderr', chunk.toString());\n        this.push(chunk);\n        next();\n      }\n    });\n    const demux = demuxer(streamc, stdout, stderr);\n\n    stderr\n      .pipe(es.split())\n      .pipe(es.parse())\n      .pipe(es.mapSync(function (data) {\n        debug('got an err event', data);\n      }));\n\n    stdout\n      .pipe(es.split())\n      .pipe(es.parse())\n      .pipe(es.mapSync(function (data) {\n        debug('got an event', data);\n        if (data.event === 'stdout') {\n          proc.stdout.write(data.data);\n        }\n        if (data.event === 'stderr') {\n          proc.stderr.write(data.data);\n        }\n        if (data.event === 'exit') {\n          proc.emit('exit', data.code);\n          streamc.unpipe(demux);\n          stdout.unpipe();\n        }\n      }));\n\n    debug('running command', command);\n    streamc.write(command);\n\n    return proc;\n  }\n}\n"]}